<application>
  <component name="AppStorage">
    <histories>
      <item value="2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none." />
      <item value="* 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false." />
      <item value="the task to execute" />
      <item value="If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current {@code RejectedExecutionHandler}." />
      <item value="Executes the given task sometime in the future. The task * may execute in a new thread or in an existing pooled thread." />
      <item value="the queue to use for holding tasks before they are * executed. This queue will hold only the {@code Runnable} * tasks submitted by the {@code execute} method." />
      <item value="the factory to use when the executor * creates a new thread" />
      <item value="when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating." />
      <item value="the number of threads to keep in the pool, even * if they are idle, unless {@code allowCoreThreadTimeOut} is se" />
      <item value="the maximum number of threads to allow in the * pool" />
      <item value="the number of threads to keep in the pool, even * if they are idle, unless {@code allowCoreThreadTimeOut} is set" />
      <item value="* Creates a new {@code ThreadPoolExecutor} with the given initial * parameters and default thread factory and rejected execution handler. * It may be more convenient to use one of the {@link Executors} factory * methods instead of this general purpose constructor." />
      <item value="the targeted parallelism level" />
      <item value="* Creates a thread pool that maintains enough threads to support * the given parallelism level, and may use multiple queues to * reduce contention. The parallelism level corresponds to the * maximum number of threads actively engaged in, or available to * engage in, task processing. The actual number of threads may * grow and shrink dynamically. A work-stealing pool makes no * guarantees about the order in which submitted tasks are * executed." />
      <item value="* Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * {@code nThreads} threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly {@link ExecutorService#shutdown shutdown}." />
      <item value="* &lt;li&gt; Methods that create and return a {@link ThreadFactory} * that sets newly created threads to a known state." />
      <item value="li&gt; Methods that create and return a &quot;wrapped&quot; ExecutorService, that * disables reconfiguration by making implementation-specific methods * inaccessible." />
      <item value="* &lt;li&gt; Methods that create and return an {@link ExecutorService} * set up with commonly useful configuration settings." />
      <item value="* Factory and utility methods for {@link Executor}, {@link * ExecutorService}, {@link ScheduledExecutorService}, {@link * ThreadFactory}, and {@link Callable} classes defined in this * package. This class supports the following kinds of methods:" />
      <item value="an integer to be converted to a string." />
      <item value="a string representation of the argument in the specified radix" />
      <item value="the radix to use in the string representation" />
      <item value="The largest possible (non-power of two) array size. * Needed by toArray and related methods." />
      <item value="* Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key." />
      <item value="* Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if * this map contains a mapping for a key &lt;tt&gt;k&lt;/tt&gt; such that * &lt;tt&gt;(key==null ? k==null : key.equals(k))&lt;/tt&gt;. (There can be * at most one such mapping.)" />
      <item value="Serializable" />
      <item value="* &lt;p&gt;Retrieval operations (including {@code get}) generally do not * block, so may overlap with update operations (including {@code put} * and {@code remove}). Retrievals reflect the results of the most * recently &lt;em&gt;completed&lt;/em&gt; update operations holding upon their * onset. (More formally, an update operation for a given key bears a * &lt;em&gt;happens-before&lt;/em&gt; relation with any (non-null) retrieval for * that key reporting the updated value.) For aggregate operations * such as {@code putAll} and {@code clear}, concurrent retrievals may * reflect insertion or removal of only some entries. Similarly, * Iterators, Spliterators and Enumerations return elements reflecting the * state of the hash table at some point at or since the creation of the * iterator/enumeration. They do &lt;em&gt;not&lt;/em&gt; throw {@link * java.util.ConcurrentModificationException ConcurrentModificationException}. * However, iterators are designed to be used by only one thread at a time. * Bear in mind that the results of aggregate status methods including * {@code size}, {@code isEmpty}, and {@code containsValue} are typically * useful only when a map is not undergoing concurrent updates in other threads. * Otherwise the results of these methods reflect transient states * that may be adequate for monitoring or estimation purposes, but not * for program control." />
      <item value="&lt;p&gt;Retrieval operations (including {@code get}) generally do not * block, so may overlap with update operations (including {@code put} * and {@code remove}). Retrievals reflect the results of the most * recently &lt;em&gt;completed&lt;/em&gt; update operations holding upon their * onset. (More formally, an update operation for a given key bears a * &lt;em&gt;happens-before&lt;/em&gt; relation with any (non-null) retrieval for * that key reporting the updated value.) For aggregate operations * such as {@code putAll} and {@code clear}, concurrent retrievals may * reflect insertion or removal of only some entries. Similarly, * Iterators, Spliterators and Enumerations return elements reflecting the * state of the hash table at some point at or since the creation of the * iterator/enumeration. They do &lt;em&gt;not&lt;/em&gt; throw {@link * java.util.ConcurrentModificationException ConcurrentModificationException}. * However, iterators are designed to be used by only one thread at a time. * Bear in mind that the results of aggregate status methods including * {@code size}, {@code isEmpty}, and {@code containsValue} are typically * useful only when a map is not undergoing concurrent updates in other threads. * Otherwise the results of these methods reflect transient states * that may be adequate for monitoring or estimation purposes, but not * for program control." />
      <item value="A hash table supporting full concurrency of retrievals and * high expected concurrency for updates. This class obeys the * same functional specification as {@link java.util.Hashtable}, and * includes versions of methods corresponding to each method of * {@code Hashtable}. However, even though all operations are * thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking, * and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table * in a way that prevents all access. This class is fully * interoperable with {@code Hashtable} in programs that rely on its * thread safety but not on its synchronization details." />
      <item value="&lt;p&gt;The &lt;tt&gt;Map&lt;/tt&gt; interface provides three &lt;i&gt;collection views&lt;/i&gt;, which * allow a map's contents to be viewed as a set of keys, collection of values, * or set of key-value mappings. The &lt;i&gt;order&lt;/i&gt; of a map is defined as * the order in which the iterators on the map's collection views return their * elements. Some map implementations, like the &lt;tt&gt;TreeMap&lt;/tt&gt; class, make * specific guarantees as to their order; others, like the &lt;tt&gt;HashMap&lt;/tt&gt; * class, do not." />
      <item value="This interface takes the place of the &lt;tt&gt;Dictionary&lt;/tt&gt; class, which * was a totally abstract class rather than an interface." />
      <item value="An object that maps keys to values. A map cannot contain duplicate keys; * each key can map to at most one value." />
      <item value="IllegalStateException implementations may, but are not * required to, throw this exception if the entry has been * removed from the backing map." />
      <item value="Returns the key corresponding to this entry." />
      <item value="Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values()." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="39" />
        <entry key="ENGLISH" value="40" />
      </map>
    </option>
  </component>
</application>